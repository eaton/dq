"use strict";var p=Object.defineProperty;var o=(t,e)=>p(t,"name",{value:e,configurable:!0});var s=require("jszip"),a=require("fs-jetpack"),h=require("micromatch"),y=require("path"),w=require("utimes");const v={output:"./output",preserveDates:!0,preservePath:!0};async function E(t,e={}){const n={...v,...e},c=await a.readAsync(t,"buffer").then(r=>{if(r)return s.loadAsync(r)});if(c===void 0)throw new Error("EBook file could not be read");let u=Object.keys(c.files);n.matching!==void 0&&(u=u.filter(r=>h.isMatch(r,n.matching)));const f=a.dir(n.output??".");for(const r of u){const i=c.file(r);if(i){const l=n.preservePath?r:y.parse(r).base,d=await i.async("nodebuffer");f.write(l,d),n.preserveDates&&await w.utimes(f.path(l),{btime:i.date,mtime:i.date})}}}o(E,"copyFiles");async function b(t){return await a.readAsync(t,"buffer").then(e=>{if(e)return s.loadAsync(e);throw new Error("EBook file could not be read")}).then(e=>Object.keys(e.files))}o(b,"listContents");async function m(t){return await a.readAsync(t,"buffer").then(e=>{if(e)return s.loadAsync(e);throw new Error("EBook file could not be read")}).then(e=>e.files["OEBPS/content.opf"]?.async("string"))}o(m,"parseMeta");async function A(t){return await a.readAsync(t,"buffer").then(e=>{if(e)return s.loadAsync(e);throw new Error("EBook file could not be read")}).then(e=>e.files["OEBPS/toc.ncx"]?.async("string"))}o(A,"parseToc"),exports.copyFiles=E,exports.listContents=b,exports.parseMeta=m,exports.parseToc=A;
