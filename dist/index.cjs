"use strict";var m=Object.defineProperty;var s=(r,e)=>m(r,"name",{value:e,configurable:!0});var f=require("jszip"),u=require("fs-jetpack"),b=require("micromatch"),h=require("path"),v=require("utimes"),g=require("xml2js"),t=require("zod");const j={output:"./output",preserveDates:!0,preservePath:!0};async function x(r,e={}){const a={...j,...e},c=await u.readAsync(r,"buffer").then(n=>{if(n)return f.loadAsync(n)});if(c===void 0)throw new Error("EBook file could not be read");let o=Object.keys(c.files);a.matching!==void 0&&(o=o.filter(n=>b.isMatch(n,a.matching)));const i=u.dir(a.output??".");for(const n of o){const l=c.file(n);if(l){const d=a.preservePath?n:h.parse(n).base,w=await l.async("nodebuffer");i.write(d,w),a.preserveDates&&await v.utimes(i.path(d),{btime:l.date,mtime:l.date})}}}s(x,"copyFiles");async function P(r){return await u.readAsync(r,"buffer").then(e=>{if(e)return f.loadAsync(e);throw new Error("EBook file could not be read")}).then(e=>Object.keys(e.files))}s(P,"listContents");const A=g.Parser,E={};async function k(r,e={}){({...E,...e});const a=await z(r),o=await new A({async:!0,explicitArray:!1,charkey:"text",normalize:!0,mergeAttrs:!0,tagNameProcessors:[i=>i.startsWith("dc:")?i.replace("dc:",""):i]}).parseStringPromise(a);return M.parse(o).package.metadata}s(k,"getMeta");async function z(r){return await u.readAsync(r,"buffer").then(e=>{if(e)return f.loadAsync(e);throw new Error("EBook file could not be read")}).then(e=>e.files["OEBPS/content.opf"]?.async("string"))}s(z,"getRawMeta");const p=t.z.string().or(t.z.object({text:t.z.string()}).transform(r=>r.text)),q=t.z.object({title:t.z.string(),creator:t.z.array(p).or(p).optional(),contributor:t.z.array(p).optional().optional(),publisher:t.z.string().optional(),rights:t.z.string().optional(),subject:t.z.array(t.z.string()).optional(),language:t.z.string(),identifier:p,source:t.z.string().optional(),date:t.z.string()}),M=t.z.object({package:t.z.object({metadata:q})}),B=g.Parser,C={};async function O(r,e={}){({...C,...e});const a=await y(r),o=await new B({async:!0,explicitArray:!1,normalize:!0,mergeAttrs:!0,trim:!0}).parseStringPromise(a);return R.parse(o).ncx.navMap.navPoint}s(O,"getToc");async function y(r){return await u.readAsync(r,"buffer").then(e=>{if(e)return f.loadAsync(e);throw new Error("EBook file could not be read")}).then(e=>e.files["OEBPS/toc.ncx"]?.async("string"))}s(y,"getRawToc");const S=t.z.string().or(t.z.object({text:t.z.string()}).transform(r=>r.text)),T=t.z.string().or(t.z.object({src:t.z.string()}).transform(r=>r.src)),$=t.z.object({id:t.z.string(),playOrder:t.z.coerce.number(),navLabel:S,content:T}),R=t.z.object({ncx:t.z.object({navMap:t.z.object({navPoint:t.z.array($)})})});exports.copyFiles=x,exports.getMeta=k,exports.getRawMeta=z,exports.getRawToc=y,exports.getToc=O,exports.listContents=P;
