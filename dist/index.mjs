var h=Object.defineProperty;var s=(r,t)=>h(r,"name",{value:t,configurable:!0});import p from"jszip";import f from"fs-jetpack";import b from"micromatch";import{parse as A}from"path";import{utimes as k}from"utimes";import m from"xml2js";import{z as e}from"zod";const E={output:"./output",preserveDates:!0,preservePath:!0};async function P(r,t={}){const a={...E,...t},c=await f.readAsync(r,"buffer").then(o=>{if(o)return p.loadAsync(o)});if(c===void 0)throw new Error("EBook file could not be read");let n=Object.keys(c.files);a.matching!==void 0&&(n=n.filter(o=>b.isMatch(o,a.matching)));const i=f.dir(a.output??".");for(const o of n){const u=c.file(o);if(u){const d=a.preservePath?o:A(o).base,w=await u.async("nodebuffer");i.write(d,w),a.preserveDates&&await k(i.path(d),{btime:u.date,mtime:u.date})}}}s(P,"copyFiles");async function x(r){return await f.readAsync(r,"buffer").then(t=>{if(t)return p.loadAsync(t);throw new Error("EBook file could not be read")}).then(t=>Object.keys(t.files))}s(x,"listContents");const j=m.Parser,v={};async function B(r,t={}){({...v,...t});const a=await y(r),n=await new j({async:!0,explicitArray:!1,charkey:"text",normalize:!0,mergeAttrs:!0,tagNameProcessors:[i=>i.startsWith("dc:")?i.replace("dc:",""):i]}).parseStringPromise(a);return S.parse(n).package.metadata}s(B,"parseMeta");async function y(r){return await f.readAsync(r,"buffer").then(t=>{if(t)return p.loadAsync(t);throw new Error("EBook file could not be read")}).then(t=>t.files["OEBPS/content.opf"]?.async("string"))}s(y,"getRawMeta");const l=e.object({id:e.string(),text:e.string()}).transform(r=>r.text),S=e.object({package:e.object({metadata:e.object({title:e.string(),creator:l,contributor:e.array(l),publisher:e.string(),rights:e.string(),subject:e.array(e.string()),language:e.string(),identifier:l,source:e.string(),date:e.string()})})}),z=m.Parser,O={};async function M(r,t={}){({...O,...t});const a=await g(r);return await new z({async:!0,explicitArray:!1,charkey:"text",normalize:!0,mergeAttrs:!0}).parseStringPromise(a)}s(M,"parseToc");async function g(r){return await f.readAsync(r,"buffer").then(t=>{if(t)return p.loadAsync(t);throw new Error("EBook file could not be read")}).then(t=>t.files["OEBPS/toc.ncx"]?.async("string"))}s(g,"getRawToc");export{P as copyFiles,y as getRawMeta,g as getRawToc,x as listContents,B as parseMeta,M as parseToc};
