var w=Object.defineProperty;var s=(e,r)=>w(e,"name",{value:r,configurable:!0});import p from"jszip";import f from"fs-jetpack";import h from"micromatch";import{parse as j}from"path";import{utimes as x}from"utimes";import d from"xml2js";import{z as t}from"zod";const P={output:"./output",preserveDates:!0,preservePath:!0};async function v(e,r={}){const o={...P,...r},c=await f.readAsync(e,"buffer").then(n=>{if(n)return p.loadAsync(n)});if(c===void 0)throw new Error("EBook file could not be read");let a=Object.keys(c.files);o.matching!==void 0&&(a=a.filter(n=>h.isMatch(n,o.matching)));const i=f.dir(o.output??".");for(const n of a){const u=c.file(n);if(u){const m=o.preservePath?n:j(n).base,b=await u.async("nodebuffer");i.write(m,b),o.preserveDates&&await x(i.path(m),{btime:u.date,mtime:u.date})}}}s(v,"copyFiles");async function A(e){return await f.readAsync(e,"buffer").then(r=>{if(r)return p.loadAsync(r);throw new Error("EBook file could not be read")}).then(r=>Object.keys(r.files))}s(A,"listContents");const E=d.Parser,k={};async function B(e,r={}){({...k,...r});const o=await g(e),a=await new E({async:!0,explicitArray:!1,charkey:"text",normalize:!0,mergeAttrs:!0,tagNameProcessors:[i=>i.startsWith("dc:")?i.replace("dc:",""):i]}).parseStringPromise(o);return O.parse(a).package.metadata}s(B,"getMeta");async function g(e){return await f.readAsync(e,"buffer").then(r=>{if(r)return p.loadAsync(r);throw new Error("EBook file could not be read")}).then(r=>r.files["OEBPS/content.opf"]?.async("string"))}s(g,"getRawMeta");const l=t.string().or(t.object({text:t.string()}).transform(e=>e.text)),M=t.object({title:t.string(),creator:t.array(l).or(l).optional(),contributor:t.array(l).optional().optional(),publisher:t.string().optional(),rights:t.string().optional(),subject:t.array(t.string()).optional(),language:t.string(),identifier:l,source:t.string().optional(),date:t.string()}),O=t.object({package:t.object({metadata:M})}),S=d.Parser,$={};async function z(e,r={}){({...$,...r});const o=await y(e),a=await new S({async:!0,explicitArray:!1,normalize:!0,mergeAttrs:!0,trim:!0}).parseStringPromise(o);return F.parse(a).ncx.navMap.navPoint}s(z,"getToc");async function y(e){return await f.readAsync(e,"buffer").then(r=>{if(r)return p.loadAsync(r);throw new Error("EBook file could not be read")}).then(r=>r.files["OEBPS/toc.ncx"]?.async("string"))}s(y,"getRawToc");const C=t.string().or(t.object({text:t.string()}).transform(e=>e.text)),T=t.string().or(t.object({src:t.string()}).transform(e=>e.src)),D=t.object({id:t.string(),playOrder:t.coerce.number(),navLabel:C,content:T}),F=t.object({ncx:t.object({navMap:t.object({navPoint:t.array(D)})})});export{v as copyFiles,B as getMeta,g as getRawMeta,y as getRawToc,z as getToc,A as listContents};
