var d=Object.defineProperty;var n=(e,t)=>d(e,"name",{value:t,configurable:!0});import s from"jszip";import i from"fs-jetpack";import h from"micromatch";import{parse as m}from"path";import{utimes as y}from"utimes";const w={output:"./output",preserveDates:!0,preservePath:!0};async function E(e,t={}){const o={...w,...t},c=await i.readAsync(e,"buffer").then(r=>{if(r)return s.loadAsync(r)});if(c===void 0)throw new Error("EBook file could not be read");let f=Object.keys(c.files);o.matching!==void 0&&(f=f.filter(r=>h.isMatch(r,o.matching)));const u=i.dir(o.output??".");for(const r of f){const a=c.file(r);if(a){const l=o.preservePath?r:m(r).base,p=await a.async("nodebuffer");u.write(l,p),o.preserveDates&&await y(u.path(l),{btime:a.date,mtime:a.date})}}}n(E,"copyFiles");async function b(e){return await i.readAsync(e,"buffer").then(t=>{if(t)return s.loadAsync(t);throw new Error("EBook file could not be read")}).then(t=>Object.keys(t.files))}n(b,"listContents");async function A(e){return await i.readAsync(e,"buffer").then(t=>{if(t)return s.loadAsync(t);throw new Error("EBook file could not be read")}).then(t=>t.files["OEBPS/content.opf"]?.async("string"))}n(A,"parseMeta");async function k(e){return await i.readAsync(e,"buffer").then(t=>{if(t)return s.loadAsync(t);throw new Error("EBook file could not be read")}).then(t=>t.files["OEBPS/toc.ncx"]?.async("string"))}n(k,"parseToc");export{E as copyFiles,b as listContents,A as parseMeta,k as parseToc};
